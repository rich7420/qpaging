# QP-Sim Project - All Source Code
# Generated: $(date)

Thu Dec 11 14:29:12 CST 2025

========================================
FILE: ./Cargo.toml
========================================

[package]
name = "qp_sim_core"
version = "0.1.0"
edition = "2021" # 相容 Rust 2024
authors = ["Q-Paging Team"]
description = "Out-of-core Quantum Simulator with Circuit-Aware Paging"

[lib]
name = "qp_sim_core"
crate-type = ["cdylib"]

[dependencies]
# Python Interop (2025 Standard)
pyo3 = { version = "0.23", features = ["extension-module", "abi3-py310"] }
numpy = "0.23"

# System & Memory
memmap2 = "0.9"     # Advanced mmap control
libc = "0.2"        # Raw system calls (madvise)
io-uring = "0.7"    # Linux Async I/O interface
bitvec = "1.0"      # Efficient page tracking

# Concurrency
tokio = { version = "1.40", features = ["rt", "macros", "fs", "sync"] }
rayon = "1.10"      # Parallel iterators for gate execution

# Math & Data
num-complex = "0.4"
ndarray = "0.16"

[profile.release]
lto = true
codegen-units = 1
panic = "abort"



========================================
FILE: ./examples/test_basic.py
========================================

"""
Basic test script for QP-Sim
Demonstrates usage with a 30-qubit circuit that would crash standard Qiskit Aer
"""
from qiskit import QuantumCircuit
from qp_sim import QPagingSimulator

# 建立一個 30 Qubits 的電路 (在普通筆電上跑 Qiskit Aer 會當機)
qc = QuantumCircuit(30)
qc.h(0)
for i in range(29):
    qc.cx(i, i+1)

# 使用 Q-Paging
backend = QPagingSimulator(backing_store="./qp_data")
job = backend.run(qc)
print("Simulation finished via Rust Core!")



========================================
FILE: ./pyproject.toml
========================================

[build-system]
requires = ["maturin>=1.7,<2.0"]
build-backend = "maturin"

[project]
name = "qp-sim"
version = "0.1.0"
description = "A deterministic, circuit-aware virtual memory manager for quantum simulation."
requires-python = ">=3.10"
classifiers = [
    "Programming Language :: Rust",
    "Programming Language :: Python :: Implementation :: CPython",
    "Operating System :: POSIX :: Linux",
]
dependencies = [
    "qiskit>=1.4.0",
    "numpy>=2.0.0",
    "psutil>=6.0.0"
]

[tool.maturin]
features = ["pyo3/extension-module"]
module-name = "qp_sim.qp_sim_core" # Map Rust lib to inside the python package



========================================
FILE: ./qp_sim/__init__.py
========================================

# Package Init
from .qp_sim_core import SimulatorController
from .qiskit_backend import QPagingSimulator

__all__ = ["SimulatorController", "QPagingSimulator"]
__version__ = "0.1.0"



========================================
FILE: ./qp_sim/qiskit_backend.py
========================================

# Qiskit Backend
from qiskit.providers import BackendV2, Options
from qiskit.transpiler import Target
from qiskit.result import Result
from qiskit.circuit import QuantumCircuit
import numpy as np
import os
import uuid

# Import our Rust Core
from .qp_sim_core import SimulatorController

class QPagingSimulator(BackendV2):
    """
    Q-Paging Backend for Qiskit.
    Offloads large state-vector simulation to an SSD-backed Rust engine.
    """
    def __init__(self, memory_limit="16GB", backing_store="./scratch_space"):
        super().__init__(name="qp_paging_simulator")
        self._memory_limit = memory_limit
        self._backing_store = backing_store
        
        # Ensure scratch directory exists
        if not os.path.exists(backing_store):
            os.makedirs(backing_store)
            
        # Define target (gates supported)
        self._target = Target()
        # In a real app, we would add_instruction for X, H, CX, etc.

    @property
    def target(self):
        return self._target

    @property
    def max_circuits(self):
        return 1

    @classmethod
    def _default_options(cls):
        return Options(shots=1024)

    def run(self, run_input, **options):
        """
        Run the circuit on the Rust Q-Paging Engine.
        """
        # 1. Handle Input (Single circuit for MVP)
        if isinstance(run_input, list):
            circuit = run_input[0]
        else:
            circuit = run_input

        # 2. Extract Circuit Info for Rust
        num_qubits = circuit.num_qubits
        
        # Parse Gates
        gate_names = []
        targets = []
        params = []
        
        for instruction in circuit.data:
            op = instruction.operation
            qubits = instruction.qubits
            
            # Map Qubit Objects to Indices
            q_indices = [circuit.find_bit(q).index for q in qubits]
            
            gate_names.append(op.name)
            targets.append(q_indices)
            params.append([float(p) for p in op.params])

        # 3. Initialize Rust Engine
        # Generate unique file for this run
        unique_filename = f"state_{uuid.uuid4()}.bin"
        file_path = os.path.join(self._backing_store, unique_filename)
        
        controller = SimulatorController(num_qubits, file_path)
        
        print(f"[Python] Offloading {num_qubits}-qubit circuit to Rust...")
        controller.initialize()
        
        # 4. Execute
        final_state = controller.run_circuit(gate_names, targets, params)
        
        # 5. Wrap Result (Simplified Mock Result for Qiskit)
        # In real world, we would format this as a proper Result object
        # with Counts or Statevector
        return JobWrapper(final_state)

class JobWrapper:
    def __init__(self, result_data):
        self._data = result_data
        
    def result(self):
        return self._data



========================================
FILE: ./src/engine/circuit.rs
========================================

// Circuit Analyzer
use std::collections::HashMap;

/// Represents a simple Quantum Gate for analysis
#[derive(Debug, Clone)]
pub struct GateOp {
    pub name: String,
    pub targets: Vec<usize>,
    pub params: Vec<f64>,
}

/// The "Global Access Schedule" generated by the analyzer
pub struct AccessSchedule {
    /// Maps Gate Index -> List of Page IDs required
    pub timeline: HashMap<usize, Vec<usize>>,
}

pub struct CircuitAnalyzer {
    page_size: usize,
    state_vector_bytes: usize,
}

impl CircuitAnalyzer {
    pub fn new(num_qubits: usize) -> Self {
        Self {
            page_size: 4096,
            state_vector_bytes: (1 << num_qubits) * 16,
        }
    }

    /// The "Lookahead" logic: Deterministically calculate pages for a gate
    pub fn analyze(&self, gates: &[GateOp]) -> AccessSchedule {
        let mut timeline = HashMap::new();
        for (idx, gate) in gates.iter().enumerate() {
            let required_pages = self.get_pages_for_gate(gate);
            timeline.insert(idx, required_pages);
        }
        AccessSchedule { timeline }
    }

    /// Core Logic: Stride Calculation
    /// Gate on qubit k => Stride = 2^k * 16 bytes
    fn get_pages_for_gate(&self, _gate: &GateOp) -> Vec<usize> {
        // Simplified Logic for MVP:
        // A single qubit gate touches memory with stride 2^k.
        // We calculate which 4KB pages these touches fall into.
        
        // NOTE: In a real implementation, this uses bit-masking to be O(1)
        // Here we simulate the logic for structure demonstration.
        
        // Example: If target is qubit 0 (LSB), stride is 16 bytes (contiguous).
        // It touches ALL pages linearly.
        // If target is qubit N (MSB), stride is half the memory.
        // It touches First Half and Second Half.
        
        // For MVP, we return a placeholder. 
        // Real implementation requires iterating the block structure.
        Vec::new()
    }
}



========================================
FILE: ./src/engine/controller.rs
========================================

// Controller
use pyo3::prelude::*;

use crate::engine::memory::QuantumMemoryManager;
use crate::engine::circuit::{CircuitAnalyzer, GateOp};
use crate::engine::io::AsyncIoEngine;

#[pyclass]
pub struct SimulatorController {
    memory: Option<QuantumMemoryManager>, // Option allows taking ownership/dropping
    num_qubits: usize,
    backing_store: String,
}

#[pymethods]
impl SimulatorController {
    #[new]
    pub fn new(num_qubits: usize, backing_store: String) -> Self {
        Self {
            memory: None,
            num_qubits,
            backing_store,
        }
    }

    /// Phase 1: Initialize Memory
    pub fn initialize(&mut self) -> PyResult<()> {
        let mem = QuantumMemoryManager::new(self.num_qubits, &self.backing_store)
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyIOError, _>(e.to_string()))?;
        
        self.memory = Some(mem);
        println!("[Rust Core] Initialized {} Qubits on SSD: {}", self.num_qubits, self.backing_store);
        Ok(())
    }

    /// Phase 2: Execute Circuit (The Main Loop)
    /// Receives a list of gates from Python
    pub fn run_circuit(&mut self, gate_names: Vec<String>, targets: Vec<Vec<usize>>, params: Vec<Vec<f64>>) -> PyResult<Vec<f64>> {
        let _mem = self.memory.as_mut().ok_or_else(|| {
            PyErr::new::<pyo3::exceptions::PyRuntimeError, _>("Memory not initialized")
        })?;

        // 1. Convert to internal GateOp
        let mut ops = Vec::new();
        for i in 0..gate_names.len() {
            ops.push(GateOp {
                name: gate_names[i].clone(),
                targets: targets[i].clone(),
                params: params[i].clone(),
            });
        }

        // 2. Analyze (Lookahead)
        let analyzer = CircuitAnalyzer::new(self.num_qubits);
        let _schedule = analyzer.analyze(&ops);

        // 3. Setup IO
        let mut _io = AsyncIoEngine::new(128).map_err(|e| {
            PyErr::new::<pyo3::exceptions::PyIOError, _>(e.to_string())
        })?;

        println!("[Rust Core] Analyzed {} gates. Starting execution loop...", ops.len());

        // 4. Execution Loop (Simplified for MVP)
        // In real implementation:
        // for (idx, gate) in ops.iter().enumerate() {
        //     scheduler.ensure_pages(idx);
        //     kernels.apply_gate(gate, mem.as_mut_slice());
        // }

        // Return dummy expectation value for test
        Ok(vec![0.0, 0.0]) 
    }
}



========================================
FILE: ./src/engine/io.rs
========================================

// Async I/O Engine
use io_uring::{opcode, types, IoUring};

/// Wrapper around Linux io_uring for high-performance paging
pub struct AsyncIoEngine {
    ring: IoUring,
}

impl AsyncIoEngine {
    pub fn new(queue_depth: u32) -> std::io::Result<Self> {
        let ring = IoUring::new(queue_depth)?;
        Ok(Self { ring })
    }

    /// Submit a prefetch request (Read from SSD -> Userspace Buffer)
    /// Note: In Q-Paging, we actually use MADV_WILLNEED or direct read 
    /// into the mmap pointer. Here we simulate a direct read trigger.
    pub fn prefetch_page(&mut self, fd: i32, buffer_ptr: *mut u8, offset: u64, len: u32) -> std::io::Result<()> {
        let read_op = opcode::Read::new(types::Fd(fd), buffer_ptr, len)
            .offset(offset)
            .build()
            .user_data(offset); // Use offset as ID for tracking
        unsafe {
            self.ring.submission().push(&read_op).expect("submission queue full");
        }
        self.ring.submit()?;
        Ok(())
    }

    /// Check which requests have finished
    /// Note: For MVP, this is a placeholder. Full implementation requires
    /// proper completion queue polling with io_uring's async API.
    pub fn poll_completions(&mut self) -> Vec<u64> {
        let mut completed_offsets = Vec::new();
        
        // TODO: Implement proper completion queue polling
        // For MVP, we use a simplified approach
        // In production, this would use io_uring's completion queue properly
        // Example: while let Some(entry) = self.ring.completion().next() { ... }
        
        completed_offsets
    }
}



========================================
FILE: ./src/engine/memory.rs
========================================

// Virtual Memory Manager
use memmap2::{MmapMut, MmapOptions};
use std::fs::File;
use std::path::Path;
use bitvec::prelude::*;

/// page size typically 4KB, usually defined by system but hardcoded for MVP
const PAGE_SIZE: usize = 4096;

/// Manages the huge state vector file and its memory mapping.
/// Implements "Scope Memory" - resources are tied to this struct's lifetime.
pub struct QuantumMemoryManager {
    mapping: MmapMut,
    _file: File, // Keep file handle open
    pub num_qubits: usize,
    pub total_bytes: usize,
    pub resident_bitmap: BitVec, // Tracks which pages are currently in DRAM
}

impl QuantumMemoryManager {
    /// Create a new memory manager backed by a file on NVMe SSD
    pub fn new(num_qubits: usize, filepath: &str) -> std::io::Result<Self> {
        let total_bytes = (1 << num_qubits) * 16; // Complex128 (16 bytes)
        
        let path = Path::new(filepath);
        let file = File::options()
            .read(true)
            .write(true)
            .create(true)
            .truncate(false)
            .open(path)?;
        // Pre-allocate disk space (prevent fragmentation)
        file.set_len(total_bytes as u64)?;
        // Create the memory map
        // Safety: We assume we have exclusive access to this file during simulation
        let mmap = unsafe { MmapOptions::new().map_mut(&file)? };
        // Advice OS: We will manage paging ourselves, don't use standard read-ahead
        unsafe {
            libc::madvise(
                mmap.as_ptr() as *mut _,
                total_bytes,
                libc::MADV_RANDOM, // Disable sequential prefetch
            );
        }
        let total_pages = (total_bytes + PAGE_SIZE - 1) / PAGE_SIZE;
        Ok(Self {
            mapping: mmap,
            _file: file,
            num_qubits,
            total_bytes,
            resident_bitmap: bitvec![0; total_pages],
        })
    }

    /// Unsafe access to the raw pointer for computation kernels
    /// The scheduler MUST ensure the relevant pages are resident before calling this.
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.mapping[..]
    }

    /// Provide advice to OS to free pages (Eviction)
    pub fn evict_page(&mut self, page_idx: usize) {
        let offset = page_idx * PAGE_SIZE;
        unsafe {
            libc::madvise(
                self.mapping.as_ptr().add(offset) as *mut _,
                PAGE_SIZE,
                libc::MADV_DONTNEED, // Aggressively free RAM
            );
        }
        self.resident_bitmap.set(page_idx, false);
    }
}

impl Drop for QuantumMemoryManager {
    fn drop(&mut self) {
        // Ensure data hits the disk before we close
        let _ = self.mapping.flush();
    }
}



========================================
FILE: ./src/engine/mod.rs
========================================

// Module Definition
pub mod memory;
pub mod circuit;
pub mod io;
pub mod controller; // Main logic binding memory, circuit, and io



========================================
FILE: ./src/lib.rs
========================================

use pyo3::prelude::*;

use crate::engine::controller::SimulatorController;

mod engine;

/// Python module definition
#[pymodule]
fn qp_sim_core(_py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    // Expose the main Controller class to Python
    m.add_class::<SimulatorController>()?;
    Ok(())
}



